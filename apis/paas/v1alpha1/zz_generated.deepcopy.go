//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Backup) DeepCopyInto(out *Backup) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Backup.
func (in *Backup) DeepCopy() *Backup {
	if in == nil {
		return nil
	}
	out := new(Backup)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Backup) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupInitParameters) DeepCopyInto(out *BackupInitParameters) {
	*out = *in
	if in.BackupID != nil {
		in, out := &in.BackupID, &out.BackupID
		*out = new(string)
		**out = **in
	}
	if in.EnableDeletionProtection != nil {
		in, out := &in.EnableDeletionProtection, &out.EnableDeletionProtection
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupInitParameters.
func (in *BackupInitParameters) DeepCopy() *BackupInitParameters {
	if in == nil {
		return nil
	}
	out := new(BackupInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupList) DeepCopyInto(out *BackupList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Backup, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupList.
func (in *BackupList) DeepCopy() *BackupList {
	if in == nil {
		return nil
	}
	out := new(BackupList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *BackupList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupObservation) DeepCopyInto(out *BackupObservation) {
	*out = *in
	if in.BackupID != nil {
		in, out := &in.BackupID, &out.BackupID
		*out = new(string)
		**out = **in
	}
	if in.Databases != nil {
		in, out := &in.Databases, &out.Databases
		*out = make([]DatabasesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EnableDeletionProtection != nil {
		in, out := &in.EnableDeletionProtection, &out.EnableDeletionProtection
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Protected != nil {
		in, out := &in.Protected, &out.Protected
		*out = new(bool)
		**out = **in
	}
	if in.ServiceClass != nil {
		in, out := &in.ServiceClass, &out.ServiceClass
		*out = new(string)
		**out = **in
	}
	if in.ServiceDeleted != nil {
		in, out := &in.ServiceDeleted, &out.ServiceDeleted
		*out = new(bool)
		**out = **in
	}
	if in.ServiceID != nil {
		in, out := &in.ServiceID, &out.ServiceID
		*out = new(string)
		**out = **in
	}
	if in.ServiceName != nil {
		in, out := &in.ServiceName, &out.ServiceName
		*out = new(string)
		**out = **in
	}
	if in.ServiceType != nil {
		in, out := &in.ServiceType, &out.ServiceType
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.Time != nil {
		in, out := &in.Time, &out.Time
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupObservation.
func (in *BackupObservation) DeepCopy() *BackupObservation {
	if in == nil {
		return nil
	}
	out := new(BackupObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupParameters) DeepCopyInto(out *BackupParameters) {
	*out = *in
	if in.BackupID != nil {
		in, out := &in.BackupID, &out.BackupID
		*out = new(string)
		**out = **in
	}
	if in.EnableDeletionProtection != nil {
		in, out := &in.EnableDeletionProtection, &out.EnableDeletionProtection
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupParameters.
func (in *BackupParameters) DeepCopy() *BackupParameters {
	if in == nil {
		return nil
	}
	out := new(BackupParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupSettingsInitParameters) DeepCopyInto(out *BackupSettingsInitParameters) {
	*out = *in
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExpirationDays != nil {
		in, out := &in.ExpirationDays, &out.ExpirationDays
		*out = new(float64)
		**out = **in
	}
	if in.NotificationEmail != nil {
		in, out := &in.NotificationEmail, &out.NotificationEmail
		*out = new(string)
		**out = **in
	}
	if in.StartTime != nil {
		in, out := &in.StartTime, &out.StartTime
		*out = new(string)
		**out = **in
	}
	if in.UserLogin != nil {
		in, out := &in.UserLogin, &out.UserLogin
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupSettingsInitParameters.
func (in *BackupSettingsInitParameters) DeepCopy() *BackupSettingsInitParameters {
	if in == nil {
		return nil
	}
	out := new(BackupSettingsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupSettingsObservation) DeepCopyInto(out *BackupSettingsObservation) {
	*out = *in
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExpirationDays != nil {
		in, out := &in.ExpirationDays, &out.ExpirationDays
		*out = new(float64)
		**out = **in
	}
	if in.NotificationEmail != nil {
		in, out := &in.NotificationEmail, &out.NotificationEmail
		*out = new(string)
		**out = **in
	}
	if in.StartTime != nil {
		in, out := &in.StartTime, &out.StartTime
		*out = new(string)
		**out = **in
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(string)
		**out = **in
	}
	if in.UserLogin != nil {
		in, out := &in.UserLogin, &out.UserLogin
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupSettingsObservation.
func (in *BackupSettingsObservation) DeepCopy() *BackupSettingsObservation {
	if in == nil {
		return nil
	}
	out := new(BackupSettingsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupSettingsParameters) DeepCopyInto(out *BackupSettingsParameters) {
	*out = *in
	if in.BucketName != nil {
		in, out := &in.BucketName, &out.BucketName
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExpirationDays != nil {
		in, out := &in.ExpirationDays, &out.ExpirationDays
		*out = new(float64)
		**out = **in
	}
	if in.NotificationEmail != nil {
		in, out := &in.NotificationEmail, &out.NotificationEmail
		*out = new(string)
		**out = **in
	}
	if in.StartTime != nil {
		in, out := &in.StartTime, &out.StartTime
		*out = new(string)
		**out = **in
	}
	if in.UserLogin != nil {
		in, out := &in.UserLogin, &out.UserLogin
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupSettingsParameters.
func (in *BackupSettingsParameters) DeepCopy() *BackupSettingsParameters {
	if in == nil {
		return nil
	}
	out := new(BackupSettingsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupSpec) DeepCopyInto(out *BackupSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupSpec.
func (in *BackupSpec) DeepCopy() *BackupSpec {
	if in == nil {
		return nil
	}
	out := new(BackupSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupStatus) DeepCopyInto(out *BackupStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupStatus.
func (in *BackupStatus) DeepCopy() *BackupStatus {
	if in == nil {
		return nil
	}
	out := new(BackupStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DataVolumeInitParameters) DeepCopyInto(out *DataVolumeInitParameters) {
	*out = *in
	if in.Iops != nil {
		in, out := &in.Iops, &out.Iops
		*out = new(float64)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DataVolumeInitParameters.
func (in *DataVolumeInitParameters) DeepCopy() *DataVolumeInitParameters {
	if in == nil {
		return nil
	}
	out := new(DataVolumeInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DataVolumeObservation) DeepCopyInto(out *DataVolumeObservation) {
	*out = *in
	if in.Iops != nil {
		in, out := &in.Iops, &out.Iops
		*out = new(float64)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DataVolumeObservation.
func (in *DataVolumeObservation) DeepCopy() *DataVolumeObservation {
	if in == nil {
		return nil
	}
	out := new(DataVolumeObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DataVolumeParameters) DeepCopyInto(out *DataVolumeParameters) {
	*out = *in
	if in.Iops != nil {
		in, out := &in.Iops, &out.Iops
		*out = new(float64)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DataVolumeParameters.
func (in *DataVolumeParameters) DeepCopy() *DataVolumeParameters {
	if in == nil {
		return nil
	}
	out := new(DataVolumeParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseInitParameters) DeepCopyInto(out *DatabaseInitParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]UserInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseInitParameters.
func (in *DatabaseInitParameters) DeepCopy() *DatabaseInitParameters {
	if in == nil {
		return nil
	}
	out := new(DatabaseInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseObservation) DeepCopyInto(out *DatabaseObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]UserObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseObservation.
func (in *DatabaseObservation) DeepCopy() *DatabaseObservation {
	if in == nil {
		return nil
	}
	out := new(DatabaseObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseParameters) DeepCopyInto(out *DatabaseParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]UserParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseParameters.
func (in *DatabaseParameters) DeepCopy() *DatabaseParameters {
	if in == nil {
		return nil
	}
	out := new(DatabaseParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseUserInitParameters) DeepCopyInto(out *DatabaseUserInitParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Privileges != nil {
		in, out := &in.Privileges, &out.Privileges
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseUserInitParameters.
func (in *DatabaseUserInitParameters) DeepCopy() *DatabaseUserInitParameters {
	if in == nil {
		return nil
	}
	out := new(DatabaseUserInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseUserObservation) DeepCopyInto(out *DatabaseUserObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Privileges != nil {
		in, out := &in.Privileges, &out.Privileges
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseUserObservation.
func (in *DatabaseUserObservation) DeepCopy() *DatabaseUserObservation {
	if in == nil {
		return nil
	}
	out := new(DatabaseUserObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabaseUserParameters) DeepCopyInto(out *DatabaseUserParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Privileges != nil {
		in, out := &in.Privileges, &out.Privileges
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabaseUserParameters.
func (in *DatabaseUserParameters) DeepCopy() *DatabaseUserParameters {
	if in == nil {
		return nil
	}
	out := new(DatabaseUserParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabasesInitParameters) DeepCopyInto(out *DatabasesInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabasesInitParameters.
func (in *DatabasesInitParameters) DeepCopy() *DatabasesInitParameters {
	if in == nil {
		return nil
	}
	out := new(DatabasesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabasesObservation) DeepCopyInto(out *DatabasesObservation) {
	*out = *in
	if in.BackupEnabled != nil {
		in, out := &in.BackupEnabled, &out.BackupEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.Logfile != nil {
		in, out := &in.Logfile, &out.Logfile
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabasesObservation.
func (in *DatabasesObservation) DeepCopy() *DatabasesObservation {
	if in == nil {
		return nil
	}
	out := new(DatabasesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DatabasesParameters) DeepCopyInto(out *DatabasesParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DatabasesParameters.
func (in *DatabasesParameters) DeepCopy() *DatabasesParameters {
	if in == nil {
		return nil
	}
	out := new(DatabasesParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ElasticsearchInitParameters) DeepCopyInto(out *ElasticsearchInitParameters) {
	*out = *in
	if in.AllowAnonymous != nil {
		in, out := &in.AllowAnonymous, &out.AllowAnonymous
		*out = new(string)
		**out = **in
	}
	if in.AnonymousRole != nil {
		in, out := &in.AnonymousRole, &out.AnonymousRole
		*out = new(string)
		**out = **in
	}
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Kibana != nil {
		in, out := &in.Kibana, &out.Kibana
		*out = new(bool)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]LoggingInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MonitoringInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ElasticsearchInitParameters.
func (in *ElasticsearchInitParameters) DeepCopy() *ElasticsearchInitParameters {
	if in == nil {
		return nil
	}
	out := new(ElasticsearchInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ElasticsearchObservation) DeepCopyInto(out *ElasticsearchObservation) {
	*out = *in
	if in.AllowAnonymous != nil {
		in, out := &in.AllowAnonymous, &out.AllowAnonymous
		*out = new(string)
		**out = **in
	}
	if in.AnonymousRole != nil {
		in, out := &in.AnonymousRole, &out.AnonymousRole
		*out = new(string)
		**out = **in
	}
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Kibana != nil {
		in, out := &in.Kibana, &out.Kibana
		*out = new(bool)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]LoggingObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MonitoringObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ElasticsearchObservation.
func (in *ElasticsearchObservation) DeepCopy() *ElasticsearchObservation {
	if in == nil {
		return nil
	}
	out := new(ElasticsearchObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ElasticsearchParameters) DeepCopyInto(out *ElasticsearchParameters) {
	*out = *in
	if in.AllowAnonymous != nil {
		in, out := &in.AllowAnonymous, &out.AllowAnonymous
		*out = new(string)
		**out = **in
	}
	if in.AnonymousRole != nil {
		in, out := &in.AnonymousRole, &out.AnonymousRole
		*out = new(string)
		**out = **in
	}
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Kibana != nil {
		in, out := &in.Kibana, &out.Kibana
		*out = new(bool)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]LoggingParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MonitoringParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ElasticsearchParameters.
func (in *ElasticsearchParameters) DeepCopy() *ElasticsearchParameters {
	if in == nil {
		return nil
	}
	out := new(ElasticsearchParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EndpointsInitParameters) DeepCopyInto(out *EndpointsInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EndpointsInitParameters.
func (in *EndpointsInitParameters) DeepCopy() *EndpointsInitParameters {
	if in == nil {
		return nil
	}
	out := new(EndpointsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EndpointsObservation) DeepCopyInto(out *EndpointsObservation) {
	*out = *in
	if in.Addresses != nil {
		in, out := &in.Addresses, &out.Addresses
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EndpointsObservation.
func (in *EndpointsObservation) DeepCopy() *EndpointsObservation {
	if in == nil {
		return nil
	}
	out := new(EndpointsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EndpointsParameters) DeepCopyInto(out *EndpointsParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EndpointsParameters.
func (in *EndpointsParameters) DeepCopy() *EndpointsParameters {
	if in == nil {
		return nil
	}
	out := new(EndpointsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InstancesEndpointsInitParameters) DeepCopyInto(out *InstancesEndpointsInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InstancesEndpointsInitParameters.
func (in *InstancesEndpointsInitParameters) DeepCopy() *InstancesEndpointsInitParameters {
	if in == nil {
		return nil
	}
	out := new(InstancesEndpointsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InstancesEndpointsObservation) DeepCopyInto(out *InstancesEndpointsObservation) {
	*out = *in
	if in.Address != nil {
		in, out := &in.Address, &out.Address
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InstancesEndpointsObservation.
func (in *InstancesEndpointsObservation) DeepCopy() *InstancesEndpointsObservation {
	if in == nil {
		return nil
	}
	out := new(InstancesEndpointsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InstancesEndpointsParameters) DeepCopyInto(out *InstancesEndpointsParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InstancesEndpointsParameters.
func (in *InstancesEndpointsParameters) DeepCopy() *InstancesEndpointsParameters {
	if in == nil {
		return nil
	}
	out := new(InstancesEndpointsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InstancesInitParameters) DeepCopyInto(out *InstancesInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InstancesInitParameters.
func (in *InstancesInitParameters) DeepCopy() *InstancesInitParameters {
	if in == nil {
		return nil
	}
	out := new(InstancesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InstancesObservation) DeepCopyInto(out *InstancesObservation) {
	*out = *in
	if in.Endpoints != nil {
		in, out := &in.Endpoints, &out.Endpoints
		*out = make([]InstancesEndpointsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Index != nil {
		in, out := &in.Index, &out.Index
		*out = new(float64)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InterfaceID != nil {
		in, out := &in.InterfaceID, &out.InterfaceID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PrivateIP != nil {
		in, out := &in.PrivateIP, &out.PrivateIP
		*out = new(string)
		**out = **in
	}
	if in.Role != nil {
		in, out := &in.Role, &out.Role
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InstancesObservation.
func (in *InstancesObservation) DeepCopy() *InstancesObservation {
	if in == nil {
		return nil
	}
	out := new(InstancesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InstancesParameters) DeepCopyInto(out *InstancesParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InstancesParameters.
func (in *InstancesParameters) DeepCopy() *InstancesParameters {
	if in == nil {
		return nil
	}
	out := new(InstancesParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingInitParameters) DeepCopyInto(out *LoggingInitParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingInitParameters.
func (in *LoggingInitParameters) DeepCopy() *LoggingInitParameters {
	if in == nil {
		return nil
	}
	out := new(LoggingInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingObservation) DeepCopyInto(out *LoggingObservation) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingObservation.
func (in *LoggingObservation) DeepCopy() *LoggingObservation {
	if in == nil {
		return nil
	}
	out := new(LoggingObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingParameters) DeepCopyInto(out *LoggingParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingParameters.
func (in *LoggingParameters) DeepCopy() *LoggingParameters {
	if in == nil {
		return nil
	}
	out := new(LoggingParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MemcachedInitParameters) DeepCopyInto(out *MemcachedInitParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]MemcachedLoggingInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MemcachedMonitoringInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MemcachedInitParameters.
func (in *MemcachedInitParameters) DeepCopy() *MemcachedInitParameters {
	if in == nil {
		return nil
	}
	out := new(MemcachedInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MemcachedLoggingInitParameters) DeepCopyInto(out *MemcachedLoggingInitParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MemcachedLoggingInitParameters.
func (in *MemcachedLoggingInitParameters) DeepCopy() *MemcachedLoggingInitParameters {
	if in == nil {
		return nil
	}
	out := new(MemcachedLoggingInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MemcachedLoggingObservation) DeepCopyInto(out *MemcachedLoggingObservation) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MemcachedLoggingObservation.
func (in *MemcachedLoggingObservation) DeepCopy() *MemcachedLoggingObservation {
	if in == nil {
		return nil
	}
	out := new(MemcachedLoggingObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MemcachedLoggingParameters) DeepCopyInto(out *MemcachedLoggingParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MemcachedLoggingParameters.
func (in *MemcachedLoggingParameters) DeepCopy() *MemcachedLoggingParameters {
	if in == nil {
		return nil
	}
	out := new(MemcachedLoggingParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MemcachedMonitoringInitParameters) DeepCopyInto(out *MemcachedMonitoringInitParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MemcachedMonitoringInitParameters.
func (in *MemcachedMonitoringInitParameters) DeepCopy() *MemcachedMonitoringInitParameters {
	if in == nil {
		return nil
	}
	out := new(MemcachedMonitoringInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MemcachedMonitoringObservation) DeepCopyInto(out *MemcachedMonitoringObservation) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MemcachedMonitoringObservation.
func (in *MemcachedMonitoringObservation) DeepCopy() *MemcachedMonitoringObservation {
	if in == nil {
		return nil
	}
	out := new(MemcachedMonitoringObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MemcachedMonitoringParameters) DeepCopyInto(out *MemcachedMonitoringParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MemcachedMonitoringParameters.
func (in *MemcachedMonitoringParameters) DeepCopy() *MemcachedMonitoringParameters {
	if in == nil {
		return nil
	}
	out := new(MemcachedMonitoringParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MemcachedObservation) DeepCopyInto(out *MemcachedObservation) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]MemcachedLoggingObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MemcachedMonitoringObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MemcachedObservation.
func (in *MemcachedObservation) DeepCopy() *MemcachedObservation {
	if in == nil {
		return nil
	}
	out := new(MemcachedObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MemcachedParameters) DeepCopyInto(out *MemcachedParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]MemcachedLoggingParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MemcachedMonitoringParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MemcachedParameters.
func (in *MemcachedParameters) DeepCopy() *MemcachedParameters {
	if in == nil {
		return nil
	}
	out := new(MemcachedParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbInitParameters) DeepCopyInto(out *MongodbInitParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = make([]DatabaseInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.JournalCommitInterval != nil {
		in, out := &in.JournalCommitInterval, &out.JournalCommitInterval
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]MongodbLoggingInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Maxconns != nil {
		in, out := &in.Maxconns, &out.Maxconns
		*out = new(float64)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MongodbMonitoringInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Profile != nil {
		in, out := &in.Profile, &out.Profile
		*out = new(string)
		**out = **in
	}
	if in.Quiet != nil {
		in, out := &in.Quiet, &out.Quiet
		*out = new(bool)
		**out = **in
	}
	if in.Slowms != nil {
		in, out := &in.Slowms, &out.Slowms
		*out = new(float64)
		**out = **in
	}
	if in.StorageEngineCacheSize != nil {
		in, out := &in.StorageEngineCacheSize, &out.StorageEngineCacheSize
		*out = new(float64)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]MongodbUserInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Verbositylevel != nil {
		in, out := &in.Verbositylevel, &out.Verbositylevel
		*out = new(string)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbInitParameters.
func (in *MongodbInitParameters) DeepCopy() *MongodbInitParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbLoggingInitParameters) DeepCopyInto(out *MongodbLoggingInitParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbLoggingInitParameters.
func (in *MongodbLoggingInitParameters) DeepCopy() *MongodbLoggingInitParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbLoggingInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbLoggingObservation) DeepCopyInto(out *MongodbLoggingObservation) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbLoggingObservation.
func (in *MongodbLoggingObservation) DeepCopy() *MongodbLoggingObservation {
	if in == nil {
		return nil
	}
	out := new(MongodbLoggingObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbLoggingParameters) DeepCopyInto(out *MongodbLoggingParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbLoggingParameters.
func (in *MongodbLoggingParameters) DeepCopy() *MongodbLoggingParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbLoggingParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbMonitoringInitParameters) DeepCopyInto(out *MongodbMonitoringInitParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbMonitoringInitParameters.
func (in *MongodbMonitoringInitParameters) DeepCopy() *MongodbMonitoringInitParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbMonitoringInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbMonitoringObservation) DeepCopyInto(out *MongodbMonitoringObservation) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbMonitoringObservation.
func (in *MongodbMonitoringObservation) DeepCopy() *MongodbMonitoringObservation {
	if in == nil {
		return nil
	}
	out := new(MongodbMonitoringObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbMonitoringParameters) DeepCopyInto(out *MongodbMonitoringParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbMonitoringParameters.
func (in *MongodbMonitoringParameters) DeepCopy() *MongodbMonitoringParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbMonitoringParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbObservation) DeepCopyInto(out *MongodbObservation) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = make([]DatabaseObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.JournalCommitInterval != nil {
		in, out := &in.JournalCommitInterval, &out.JournalCommitInterval
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]MongodbLoggingObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Maxconns != nil {
		in, out := &in.Maxconns, &out.Maxconns
		*out = new(float64)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MongodbMonitoringObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Profile != nil {
		in, out := &in.Profile, &out.Profile
		*out = new(string)
		**out = **in
	}
	if in.Quiet != nil {
		in, out := &in.Quiet, &out.Quiet
		*out = new(bool)
		**out = **in
	}
	if in.Slowms != nil {
		in, out := &in.Slowms, &out.Slowms
		*out = new(float64)
		**out = **in
	}
	if in.StorageEngineCacheSize != nil {
		in, out := &in.StorageEngineCacheSize, &out.StorageEngineCacheSize
		*out = new(float64)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]MongodbUserObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Verbositylevel != nil {
		in, out := &in.Verbositylevel, &out.Verbositylevel
		*out = new(string)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbObservation.
func (in *MongodbObservation) DeepCopy() *MongodbObservation {
	if in == nil {
		return nil
	}
	out := new(MongodbObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbParameters) DeepCopyInto(out *MongodbParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = make([]DatabaseParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.JournalCommitInterval != nil {
		in, out := &in.JournalCommitInterval, &out.JournalCommitInterval
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]MongodbLoggingParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Maxconns != nil {
		in, out := &in.Maxconns, &out.Maxconns
		*out = new(float64)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MongodbMonitoringParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Profile != nil {
		in, out := &in.Profile, &out.Profile
		*out = new(string)
		**out = **in
	}
	if in.Quiet != nil {
		in, out := &in.Quiet, &out.Quiet
		*out = new(bool)
		**out = **in
	}
	if in.Slowms != nil {
		in, out := &in.Slowms, &out.Slowms
		*out = new(float64)
		**out = **in
	}
	if in.StorageEngineCacheSize != nil {
		in, out := &in.StorageEngineCacheSize, &out.StorageEngineCacheSize
		*out = new(float64)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]MongodbUserParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Verbositylevel != nil {
		in, out := &in.Verbositylevel, &out.Verbositylevel
		*out = new(string)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbParameters.
func (in *MongodbParameters) DeepCopy() *MongodbParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbUserInitParameters) DeepCopyInto(out *MongodbUserInitParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbUserInitParameters.
func (in *MongodbUserInitParameters) DeepCopy() *MongodbUserInitParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbUserInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbUserObservation) DeepCopyInto(out *MongodbUserObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbUserObservation.
func (in *MongodbUserObservation) DeepCopy() *MongodbUserObservation {
	if in == nil {
		return nil
	}
	out := new(MongodbUserObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongodbUserParameters) DeepCopyInto(out *MongodbUserParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongodbUserParameters.
func (in *MongodbUserParameters) DeepCopy() *MongodbUserParameters {
	if in == nil {
		return nil
	}
	out := new(MongodbUserParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MonitoringInitParameters) DeepCopyInto(out *MonitoringInitParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MonitoringInitParameters.
func (in *MonitoringInitParameters) DeepCopy() *MonitoringInitParameters {
	if in == nil {
		return nil
	}
	out := new(MonitoringInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MonitoringObservation) DeepCopyInto(out *MonitoringObservation) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MonitoringObservation.
func (in *MonitoringObservation) DeepCopy() *MonitoringObservation {
	if in == nil {
		return nil
	}
	out := new(MonitoringObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MonitoringParameters) DeepCopyInto(out *MonitoringParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MonitoringParameters.
func (in *MonitoringParameters) DeepCopy() *MonitoringParameters {
	if in == nil {
		return nil
	}
	out := new(MonitoringParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLDatabaseInitParameters) DeepCopyInto(out *MySQLDatabaseInitParameters) {
	*out = *in
	if in.BackupDBName != nil {
		in, out := &in.BackupDBName, &out.BackupDBName
		*out = new(string)
		**out = **in
	}
	if in.BackupEnabled != nil {
		in, out := &in.BackupEnabled, &out.BackupEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BackupID != nil {
		in, out := &in.BackupID, &out.BackupID
		*out = new(string)
		**out = **in
	}
	if in.Charset != nil {
		in, out := &in.Charset, &out.Charset
		*out = new(string)
		**out = **in
	}
	if in.Collate != nil {
		in, out := &in.Collate, &out.Collate
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]DatabaseUserInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLDatabaseInitParameters.
func (in *MySQLDatabaseInitParameters) DeepCopy() *MySQLDatabaseInitParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLDatabaseInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLDatabaseObservation) DeepCopyInto(out *MySQLDatabaseObservation) {
	*out = *in
	if in.BackupDBName != nil {
		in, out := &in.BackupDBName, &out.BackupDBName
		*out = new(string)
		**out = **in
	}
	if in.BackupEnabled != nil {
		in, out := &in.BackupEnabled, &out.BackupEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BackupID != nil {
		in, out := &in.BackupID, &out.BackupID
		*out = new(string)
		**out = **in
	}
	if in.Charset != nil {
		in, out := &in.Charset, &out.Charset
		*out = new(string)
		**out = **in
	}
	if in.Collate != nil {
		in, out := &in.Collate, &out.Collate
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]DatabaseUserObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLDatabaseObservation.
func (in *MySQLDatabaseObservation) DeepCopy() *MySQLDatabaseObservation {
	if in == nil {
		return nil
	}
	out := new(MySQLDatabaseObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLDatabaseParameters) DeepCopyInto(out *MySQLDatabaseParameters) {
	*out = *in
	if in.BackupDBName != nil {
		in, out := &in.BackupDBName, &out.BackupDBName
		*out = new(string)
		**out = **in
	}
	if in.BackupEnabled != nil {
		in, out := &in.BackupEnabled, &out.BackupEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BackupID != nil {
		in, out := &in.BackupID, &out.BackupID
		*out = new(string)
		**out = **in
	}
	if in.Charset != nil {
		in, out := &in.Charset, &out.Charset
		*out = new(string)
		**out = **in
	}
	if in.Collate != nil {
		in, out := &in.Collate, &out.Collate
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]DatabaseUserParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLDatabaseParameters.
func (in *MySQLDatabaseParameters) DeepCopy() *MySQLDatabaseParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLDatabaseParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLInitParameters) DeepCopyInto(out *MySQLInitParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = make([]MySQLDatabaseInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.GaleraOptions != nil {
		in, out := &in.GaleraOptions, &out.GaleraOptions
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.GcacheSize != nil {
		in, out := &in.GcacheSize, &out.GcacheSize
		*out = new(float64)
		**out = **in
	}
	if in.GcsFcFactor != nil {
		in, out := &in.GcsFcFactor, &out.GcsFcFactor
		*out = new(float64)
		**out = **in
	}
	if in.GcsFcLimit != nil {
		in, out := &in.GcsFcLimit, &out.GcsFcLimit
		*out = new(float64)
		**out = **in
	}
	if in.GcsFcMasterSlave != nil {
		in, out := &in.GcsFcMasterSlave, &out.GcsFcMasterSlave
		*out = new(string)
		**out = **in
	}
	if in.GcsFcSinglePrimary != nil {
		in, out := &in.GcsFcSinglePrimary, &out.GcsFcSinglePrimary
		*out = new(string)
		**out = **in
	}
	if in.InnodbBufferPoolInstances != nil {
		in, out := &in.InnodbBufferPoolInstances, &out.InnodbBufferPoolInstances
		*out = new(float64)
		**out = **in
	}
	if in.InnodbBufferPoolSize != nil {
		in, out := &in.InnodbBufferPoolSize, &out.InnodbBufferPoolSize
		*out = new(string)
		**out = **in
	}
	if in.InnodbChangeBuffering != nil {
		in, out := &in.InnodbChangeBuffering, &out.InnodbChangeBuffering
		*out = new(string)
		**out = **in
	}
	if in.InnodbFlushLogAtTrxCommit != nil {
		in, out := &in.InnodbFlushLogAtTrxCommit, &out.InnodbFlushLogAtTrxCommit
		*out = new(float64)
		**out = **in
	}
	if in.InnodbIoCapacity != nil {
		in, out := &in.InnodbIoCapacity, &out.InnodbIoCapacity
		*out = new(string)
		**out = **in
	}
	if in.InnodbIoCapacityMax != nil {
		in, out := &in.InnodbIoCapacityMax, &out.InnodbIoCapacityMax
		*out = new(string)
		**out = **in
	}
	if in.InnodbLogFileSize != nil {
		in, out := &in.InnodbLogFileSize, &out.InnodbLogFileSize
		*out = new(string)
		**out = **in
	}
	if in.InnodbLogFilesInGroup != nil {
		in, out := &in.InnodbLogFilesInGroup, &out.InnodbLogFilesInGroup
		*out = new(float64)
		**out = **in
	}
	if in.InnodbPurgeThreads != nil {
		in, out := &in.InnodbPurgeThreads, &out.InnodbPurgeThreads
		*out = new(float64)
		**out = **in
	}
	if in.InnodbStrictMode != nil {
		in, out := &in.InnodbStrictMode, &out.InnodbStrictMode
		*out = new(string)
		**out = **in
	}
	if in.InnodbSyncArraySize != nil {
		in, out := &in.InnodbSyncArraySize, &out.InnodbSyncArraySize
		*out = new(float64)
		**out = **in
	}
	if in.InnodbThreadConcurrency != nil {
		in, out := &in.InnodbThreadConcurrency, &out.InnodbThreadConcurrency
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]MySQLLoggingInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MaxAllowedPacket != nil {
		in, out := &in.MaxAllowedPacket, &out.MaxAllowedPacket
		*out = new(float64)
		**out = **in
	}
	if in.MaxConnectErrors != nil {
		in, out := &in.MaxConnectErrors, &out.MaxConnectErrors
		*out = new(string)
		**out = **in
	}
	if in.MaxConnections != nil {
		in, out := &in.MaxConnections, &out.MaxConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxHeapTableSize != nil {
		in, out := &in.MaxHeapTableSize, &out.MaxHeapTableSize
		*out = new(string)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MySQLMonitoringInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.PxcStrictMode != nil {
		in, out := &in.PxcStrictMode, &out.PxcStrictMode
		*out = new(string)
		**out = **in
	}
	if in.TableOpenCache != nil {
		in, out := &in.TableOpenCache, &out.TableOpenCache
		*out = new(float64)
		**out = **in
	}
	if in.ThreadCacheSize != nil {
		in, out := &in.ThreadCacheSize, &out.ThreadCacheSize
		*out = new(float64)
		**out = **in
	}
	if in.TmpTableSize != nil {
		in, out := &in.TmpTableSize, &out.TmpTableSize
		*out = new(string)
		**out = **in
	}
	if in.TransactionIsolation != nil {
		in, out := &in.TransactionIsolation, &out.TransactionIsolation
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]MySQLUserInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Vendor != nil {
		in, out := &in.Vendor, &out.Vendor
		*out = new(string)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
	if in.WaitTimeout != nil {
		in, out := &in.WaitTimeout, &out.WaitTimeout
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLInitParameters.
func (in *MySQLInitParameters) DeepCopy() *MySQLInitParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLLoggingInitParameters) DeepCopyInto(out *MySQLLoggingInitParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLLoggingInitParameters.
func (in *MySQLLoggingInitParameters) DeepCopy() *MySQLLoggingInitParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLLoggingInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLLoggingObservation) DeepCopyInto(out *MySQLLoggingObservation) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLLoggingObservation.
func (in *MySQLLoggingObservation) DeepCopy() *MySQLLoggingObservation {
	if in == nil {
		return nil
	}
	out := new(MySQLLoggingObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLLoggingParameters) DeepCopyInto(out *MySQLLoggingParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLLoggingParameters.
func (in *MySQLLoggingParameters) DeepCopy() *MySQLLoggingParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLLoggingParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLMonitoringInitParameters) DeepCopyInto(out *MySQLMonitoringInitParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLMonitoringInitParameters.
func (in *MySQLMonitoringInitParameters) DeepCopy() *MySQLMonitoringInitParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLMonitoringInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLMonitoringObservation) DeepCopyInto(out *MySQLMonitoringObservation) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLMonitoringObservation.
func (in *MySQLMonitoringObservation) DeepCopy() *MySQLMonitoringObservation {
	if in == nil {
		return nil
	}
	out := new(MySQLMonitoringObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLMonitoringParameters) DeepCopyInto(out *MySQLMonitoringParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLMonitoringParameters.
func (in *MySQLMonitoringParameters) DeepCopy() *MySQLMonitoringParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLMonitoringParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLObservation) DeepCopyInto(out *MySQLObservation) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = make([]MySQLDatabaseObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.GaleraOptions != nil {
		in, out := &in.GaleraOptions, &out.GaleraOptions
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.GcacheSize != nil {
		in, out := &in.GcacheSize, &out.GcacheSize
		*out = new(float64)
		**out = **in
	}
	if in.GcsFcFactor != nil {
		in, out := &in.GcsFcFactor, &out.GcsFcFactor
		*out = new(float64)
		**out = **in
	}
	if in.GcsFcLimit != nil {
		in, out := &in.GcsFcLimit, &out.GcsFcLimit
		*out = new(float64)
		**out = **in
	}
	if in.GcsFcMasterSlave != nil {
		in, out := &in.GcsFcMasterSlave, &out.GcsFcMasterSlave
		*out = new(string)
		**out = **in
	}
	if in.GcsFcSinglePrimary != nil {
		in, out := &in.GcsFcSinglePrimary, &out.GcsFcSinglePrimary
		*out = new(string)
		**out = **in
	}
	if in.InnodbBufferPoolInstances != nil {
		in, out := &in.InnodbBufferPoolInstances, &out.InnodbBufferPoolInstances
		*out = new(float64)
		**out = **in
	}
	if in.InnodbBufferPoolSize != nil {
		in, out := &in.InnodbBufferPoolSize, &out.InnodbBufferPoolSize
		*out = new(string)
		**out = **in
	}
	if in.InnodbChangeBuffering != nil {
		in, out := &in.InnodbChangeBuffering, &out.InnodbChangeBuffering
		*out = new(string)
		**out = **in
	}
	if in.InnodbFlushLogAtTrxCommit != nil {
		in, out := &in.InnodbFlushLogAtTrxCommit, &out.InnodbFlushLogAtTrxCommit
		*out = new(float64)
		**out = **in
	}
	if in.InnodbIoCapacity != nil {
		in, out := &in.InnodbIoCapacity, &out.InnodbIoCapacity
		*out = new(string)
		**out = **in
	}
	if in.InnodbIoCapacityMax != nil {
		in, out := &in.InnodbIoCapacityMax, &out.InnodbIoCapacityMax
		*out = new(string)
		**out = **in
	}
	if in.InnodbLogFileSize != nil {
		in, out := &in.InnodbLogFileSize, &out.InnodbLogFileSize
		*out = new(string)
		**out = **in
	}
	if in.InnodbLogFilesInGroup != nil {
		in, out := &in.InnodbLogFilesInGroup, &out.InnodbLogFilesInGroup
		*out = new(float64)
		**out = **in
	}
	if in.InnodbPurgeThreads != nil {
		in, out := &in.InnodbPurgeThreads, &out.InnodbPurgeThreads
		*out = new(float64)
		**out = **in
	}
	if in.InnodbStrictMode != nil {
		in, out := &in.InnodbStrictMode, &out.InnodbStrictMode
		*out = new(string)
		**out = **in
	}
	if in.InnodbSyncArraySize != nil {
		in, out := &in.InnodbSyncArraySize, &out.InnodbSyncArraySize
		*out = new(float64)
		**out = **in
	}
	if in.InnodbThreadConcurrency != nil {
		in, out := &in.InnodbThreadConcurrency, &out.InnodbThreadConcurrency
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]MySQLLoggingObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MaxAllowedPacket != nil {
		in, out := &in.MaxAllowedPacket, &out.MaxAllowedPacket
		*out = new(float64)
		**out = **in
	}
	if in.MaxConnectErrors != nil {
		in, out := &in.MaxConnectErrors, &out.MaxConnectErrors
		*out = new(string)
		**out = **in
	}
	if in.MaxConnections != nil {
		in, out := &in.MaxConnections, &out.MaxConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxHeapTableSize != nil {
		in, out := &in.MaxHeapTableSize, &out.MaxHeapTableSize
		*out = new(string)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MySQLMonitoringObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.PxcStrictMode != nil {
		in, out := &in.PxcStrictMode, &out.PxcStrictMode
		*out = new(string)
		**out = **in
	}
	if in.TableOpenCache != nil {
		in, out := &in.TableOpenCache, &out.TableOpenCache
		*out = new(float64)
		**out = **in
	}
	if in.ThreadCacheSize != nil {
		in, out := &in.ThreadCacheSize, &out.ThreadCacheSize
		*out = new(float64)
		**out = **in
	}
	if in.TmpTableSize != nil {
		in, out := &in.TmpTableSize, &out.TmpTableSize
		*out = new(string)
		**out = **in
	}
	if in.TransactionIsolation != nil {
		in, out := &in.TransactionIsolation, &out.TransactionIsolation
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]MySQLUserObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Vendor != nil {
		in, out := &in.Vendor, &out.Vendor
		*out = new(string)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
	if in.WaitTimeout != nil {
		in, out := &in.WaitTimeout, &out.WaitTimeout
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLObservation.
func (in *MySQLObservation) DeepCopy() *MySQLObservation {
	if in == nil {
		return nil
	}
	out := new(MySQLObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLParameters) DeepCopyInto(out *MySQLParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.ConnectTimeout != nil {
		in, out := &in.ConnectTimeout, &out.ConnectTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = make([]MySQLDatabaseParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.GaleraOptions != nil {
		in, out := &in.GaleraOptions, &out.GaleraOptions
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.GcacheSize != nil {
		in, out := &in.GcacheSize, &out.GcacheSize
		*out = new(float64)
		**out = **in
	}
	if in.GcsFcFactor != nil {
		in, out := &in.GcsFcFactor, &out.GcsFcFactor
		*out = new(float64)
		**out = **in
	}
	if in.GcsFcLimit != nil {
		in, out := &in.GcsFcLimit, &out.GcsFcLimit
		*out = new(float64)
		**out = **in
	}
	if in.GcsFcMasterSlave != nil {
		in, out := &in.GcsFcMasterSlave, &out.GcsFcMasterSlave
		*out = new(string)
		**out = **in
	}
	if in.GcsFcSinglePrimary != nil {
		in, out := &in.GcsFcSinglePrimary, &out.GcsFcSinglePrimary
		*out = new(string)
		**out = **in
	}
	if in.InnodbBufferPoolInstances != nil {
		in, out := &in.InnodbBufferPoolInstances, &out.InnodbBufferPoolInstances
		*out = new(float64)
		**out = **in
	}
	if in.InnodbBufferPoolSize != nil {
		in, out := &in.InnodbBufferPoolSize, &out.InnodbBufferPoolSize
		*out = new(string)
		**out = **in
	}
	if in.InnodbChangeBuffering != nil {
		in, out := &in.InnodbChangeBuffering, &out.InnodbChangeBuffering
		*out = new(string)
		**out = **in
	}
	if in.InnodbFlushLogAtTrxCommit != nil {
		in, out := &in.InnodbFlushLogAtTrxCommit, &out.InnodbFlushLogAtTrxCommit
		*out = new(float64)
		**out = **in
	}
	if in.InnodbIoCapacity != nil {
		in, out := &in.InnodbIoCapacity, &out.InnodbIoCapacity
		*out = new(string)
		**out = **in
	}
	if in.InnodbIoCapacityMax != nil {
		in, out := &in.InnodbIoCapacityMax, &out.InnodbIoCapacityMax
		*out = new(string)
		**out = **in
	}
	if in.InnodbLogFileSize != nil {
		in, out := &in.InnodbLogFileSize, &out.InnodbLogFileSize
		*out = new(string)
		**out = **in
	}
	if in.InnodbLogFilesInGroup != nil {
		in, out := &in.InnodbLogFilesInGroup, &out.InnodbLogFilesInGroup
		*out = new(float64)
		**out = **in
	}
	if in.InnodbPurgeThreads != nil {
		in, out := &in.InnodbPurgeThreads, &out.InnodbPurgeThreads
		*out = new(float64)
		**out = **in
	}
	if in.InnodbStrictMode != nil {
		in, out := &in.InnodbStrictMode, &out.InnodbStrictMode
		*out = new(string)
		**out = **in
	}
	if in.InnodbSyncArraySize != nil {
		in, out := &in.InnodbSyncArraySize, &out.InnodbSyncArraySize
		*out = new(float64)
		**out = **in
	}
	if in.InnodbThreadConcurrency != nil {
		in, out := &in.InnodbThreadConcurrency, &out.InnodbThreadConcurrency
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]MySQLLoggingParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MaxAllowedPacket != nil {
		in, out := &in.MaxAllowedPacket, &out.MaxAllowedPacket
		*out = new(float64)
		**out = **in
	}
	if in.MaxConnectErrors != nil {
		in, out := &in.MaxConnectErrors, &out.MaxConnectErrors
		*out = new(string)
		**out = **in
	}
	if in.MaxConnections != nil {
		in, out := &in.MaxConnections, &out.MaxConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxHeapTableSize != nil {
		in, out := &in.MaxHeapTableSize, &out.MaxHeapTableSize
		*out = new(string)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]MySQLMonitoringParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.PxcStrictMode != nil {
		in, out := &in.PxcStrictMode, &out.PxcStrictMode
		*out = new(string)
		**out = **in
	}
	if in.TableOpenCache != nil {
		in, out := &in.TableOpenCache, &out.TableOpenCache
		*out = new(float64)
		**out = **in
	}
	if in.ThreadCacheSize != nil {
		in, out := &in.ThreadCacheSize, &out.ThreadCacheSize
		*out = new(float64)
		**out = **in
	}
	if in.TmpTableSize != nil {
		in, out := &in.TmpTableSize, &out.TmpTableSize
		*out = new(string)
		**out = **in
	}
	if in.TransactionIsolation != nil {
		in, out := &in.TransactionIsolation, &out.TransactionIsolation
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]MySQLUserParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Vendor != nil {
		in, out := &in.Vendor, &out.Vendor
		*out = new(string)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
	if in.WaitTimeout != nil {
		in, out := &in.WaitTimeout, &out.WaitTimeout
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLParameters.
func (in *MySQLParameters) DeepCopy() *MySQLParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLUserInitParameters) DeepCopyInto(out *MySQLUserInitParameters) {
	*out = *in
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLUserInitParameters.
func (in *MySQLUserInitParameters) DeepCopy() *MySQLUserInitParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLUserInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLUserObservation) DeepCopyInto(out *MySQLUserObservation) {
	*out = *in
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLUserObservation.
func (in *MySQLUserObservation) DeepCopy() *MySQLUserObservation {
	if in == nil {
		return nil
	}
	out := new(MySQLUserObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MySQLUserParameters) DeepCopyInto(out *MySQLUserParameters) {
	*out = *in
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MySQLUserParameters.
func (in *MySQLUserParameters) DeepCopy() *MySQLUserParameters {
	if in == nil {
		return nil
	}
	out := new(MySQLUserParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlDatabaseInitParameters) DeepCopyInto(out *PgsqlDatabaseInitParameters) {
	*out = *in
	if in.BackupDBName != nil {
		in, out := &in.BackupDBName, &out.BackupDBName
		*out = new(string)
		**out = **in
	}
	if in.BackupEnabled != nil {
		in, out := &in.BackupEnabled, &out.BackupEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BackupID != nil {
		in, out := &in.BackupID, &out.BackupID
		*out = new(string)
		**out = **in
	}
	if in.Encoding != nil {
		in, out := &in.Encoding, &out.Encoding
		*out = new(string)
		**out = **in
	}
	if in.Extensions != nil {
		in, out := &in.Extensions, &out.Extensions
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Locale != nil {
		in, out := &in.Locale, &out.Locale
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]PgsqlDatabaseUserInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlDatabaseInitParameters.
func (in *PgsqlDatabaseInitParameters) DeepCopy() *PgsqlDatabaseInitParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlDatabaseInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlDatabaseObservation) DeepCopyInto(out *PgsqlDatabaseObservation) {
	*out = *in
	if in.BackupDBName != nil {
		in, out := &in.BackupDBName, &out.BackupDBName
		*out = new(string)
		**out = **in
	}
	if in.BackupEnabled != nil {
		in, out := &in.BackupEnabled, &out.BackupEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BackupID != nil {
		in, out := &in.BackupID, &out.BackupID
		*out = new(string)
		**out = **in
	}
	if in.Encoding != nil {
		in, out := &in.Encoding, &out.Encoding
		*out = new(string)
		**out = **in
	}
	if in.Extensions != nil {
		in, out := &in.Extensions, &out.Extensions
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Locale != nil {
		in, out := &in.Locale, &out.Locale
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]PgsqlDatabaseUserObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlDatabaseObservation.
func (in *PgsqlDatabaseObservation) DeepCopy() *PgsqlDatabaseObservation {
	if in == nil {
		return nil
	}
	out := new(PgsqlDatabaseObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlDatabaseParameters) DeepCopyInto(out *PgsqlDatabaseParameters) {
	*out = *in
	if in.BackupDBName != nil {
		in, out := &in.BackupDBName, &out.BackupDBName
		*out = new(string)
		**out = **in
	}
	if in.BackupEnabled != nil {
		in, out := &in.BackupEnabled, &out.BackupEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BackupID != nil {
		in, out := &in.BackupID, &out.BackupID
		*out = new(string)
		**out = **in
	}
	if in.Encoding != nil {
		in, out := &in.Encoding, &out.Encoding
		*out = new(string)
		**out = **in
	}
	if in.Extensions != nil {
		in, out := &in.Extensions, &out.Extensions
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Locale != nil {
		in, out := &in.Locale, &out.Locale
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]PgsqlDatabaseUserParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlDatabaseParameters.
func (in *PgsqlDatabaseParameters) DeepCopy() *PgsqlDatabaseParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlDatabaseParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlDatabaseUserInitParameters) DeepCopyInto(out *PgsqlDatabaseUserInitParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlDatabaseUserInitParameters.
func (in *PgsqlDatabaseUserInitParameters) DeepCopy() *PgsqlDatabaseUserInitParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlDatabaseUserInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlDatabaseUserObservation) DeepCopyInto(out *PgsqlDatabaseUserObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlDatabaseUserObservation.
func (in *PgsqlDatabaseUserObservation) DeepCopy() *PgsqlDatabaseUserObservation {
	if in == nil {
		return nil
	}
	out := new(PgsqlDatabaseUserObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlDatabaseUserParameters) DeepCopyInto(out *PgsqlDatabaseUserParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlDatabaseUserParameters.
func (in *PgsqlDatabaseUserParameters) DeepCopy() *PgsqlDatabaseUserParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlDatabaseUserParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlInitParameters) DeepCopyInto(out *PgsqlInitParameters) {
	*out = *in
	if in.Autovacuum != nil {
		in, out := &in.Autovacuum, &out.Autovacuum
		*out = new(string)
		**out = **in
	}
	if in.AutovacuumAnalyzeScaleFactor != nil {
		in, out := &in.AutovacuumAnalyzeScaleFactor, &out.AutovacuumAnalyzeScaleFactor
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumMaxWorkers != nil {
		in, out := &in.AutovacuumMaxWorkers, &out.AutovacuumMaxWorkers
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumVacuumCostDelay != nil {
		in, out := &in.AutovacuumVacuumCostDelay, &out.AutovacuumVacuumCostDelay
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumVacuumCostLimit != nil {
		in, out := &in.AutovacuumVacuumCostLimit, &out.AutovacuumVacuumCostLimit
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumVacuumScaleFactor != nil {
		in, out := &in.AutovacuumVacuumScaleFactor, &out.AutovacuumVacuumScaleFactor
		*out = new(float64)
		**out = **in
	}
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = make([]PgsqlDatabaseInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EffectiveCacheSize != nil {
		in, out := &in.EffectiveCacheSize, &out.EffectiveCacheSize
		*out = new(string)
		**out = **in
	}
	if in.EffectiveIoConcurrency != nil {
		in, out := &in.EffectiveIoConcurrency, &out.EffectiveIoConcurrency
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]PgsqlLoggingInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MaintenanceWorkMem != nil {
		in, out := &in.MaintenanceWorkMem, &out.MaintenanceWorkMem
		*out = new(string)
		**out = **in
	}
	if in.MaxConnections != nil {
		in, out := &in.MaxConnections, &out.MaxConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxParallelMaintenanceWorkers != nil {
		in, out := &in.MaxParallelMaintenanceWorkers, &out.MaxParallelMaintenanceWorkers
		*out = new(float64)
		**out = **in
	}
	if in.MaxParallelWorkers != nil {
		in, out := &in.MaxParallelWorkers, &out.MaxParallelWorkers
		*out = new(float64)
		**out = **in
	}
	if in.MaxParallelWorkersPerGather != nil {
		in, out := &in.MaxParallelWorkersPerGather, &out.MaxParallelWorkersPerGather
		*out = new(float64)
		**out = **in
	}
	if in.MaxWalSize != nil {
		in, out := &in.MaxWalSize, &out.MaxWalSize
		*out = new(string)
		**out = **in
	}
	if in.MaxWorkerProcesses != nil {
		in, out := &in.MaxWorkerProcesses, &out.MaxWorkerProcesses
		*out = new(float64)
		**out = **in
	}
	if in.MinWalSize != nil {
		in, out := &in.MinWalSize, &out.MinWalSize
		*out = new(string)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]PgsqlMonitoringInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.ReplicationMode != nil {
		in, out := &in.ReplicationMode, &out.ReplicationMode
		*out = new(string)
		**out = **in
	}
	if in.SharedBuffers != nil {
		in, out := &in.SharedBuffers, &out.SharedBuffers
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]PgsqlUserInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
	if in.WalBuffers != nil {
		in, out := &in.WalBuffers, &out.WalBuffers
		*out = new(float64)
		**out = **in
	}
	if in.WalKeepSegments != nil {
		in, out := &in.WalKeepSegments, &out.WalKeepSegments
		*out = new(float64)
		**out = **in
	}
	if in.WorkMem != nil {
		in, out := &in.WorkMem, &out.WorkMem
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlInitParameters.
func (in *PgsqlInitParameters) DeepCopy() *PgsqlInitParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlLoggingInitParameters) DeepCopyInto(out *PgsqlLoggingInitParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlLoggingInitParameters.
func (in *PgsqlLoggingInitParameters) DeepCopy() *PgsqlLoggingInitParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlLoggingInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlLoggingObservation) DeepCopyInto(out *PgsqlLoggingObservation) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlLoggingObservation.
func (in *PgsqlLoggingObservation) DeepCopy() *PgsqlLoggingObservation {
	if in == nil {
		return nil
	}
	out := new(PgsqlLoggingObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlLoggingParameters) DeepCopyInto(out *PgsqlLoggingParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlLoggingParameters.
func (in *PgsqlLoggingParameters) DeepCopy() *PgsqlLoggingParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlLoggingParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlMonitoringInitParameters) DeepCopyInto(out *PgsqlMonitoringInitParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlMonitoringInitParameters.
func (in *PgsqlMonitoringInitParameters) DeepCopy() *PgsqlMonitoringInitParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlMonitoringInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlMonitoringObservation) DeepCopyInto(out *PgsqlMonitoringObservation) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlMonitoringObservation.
func (in *PgsqlMonitoringObservation) DeepCopy() *PgsqlMonitoringObservation {
	if in == nil {
		return nil
	}
	out := new(PgsqlMonitoringObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlMonitoringParameters) DeepCopyInto(out *PgsqlMonitoringParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlMonitoringParameters.
func (in *PgsqlMonitoringParameters) DeepCopy() *PgsqlMonitoringParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlMonitoringParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlObservation) DeepCopyInto(out *PgsqlObservation) {
	*out = *in
	if in.Autovacuum != nil {
		in, out := &in.Autovacuum, &out.Autovacuum
		*out = new(string)
		**out = **in
	}
	if in.AutovacuumAnalyzeScaleFactor != nil {
		in, out := &in.AutovacuumAnalyzeScaleFactor, &out.AutovacuumAnalyzeScaleFactor
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumMaxWorkers != nil {
		in, out := &in.AutovacuumMaxWorkers, &out.AutovacuumMaxWorkers
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumVacuumCostDelay != nil {
		in, out := &in.AutovacuumVacuumCostDelay, &out.AutovacuumVacuumCostDelay
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumVacuumCostLimit != nil {
		in, out := &in.AutovacuumVacuumCostLimit, &out.AutovacuumVacuumCostLimit
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumVacuumScaleFactor != nil {
		in, out := &in.AutovacuumVacuumScaleFactor, &out.AutovacuumVacuumScaleFactor
		*out = new(float64)
		**out = **in
	}
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = make([]PgsqlDatabaseObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EffectiveCacheSize != nil {
		in, out := &in.EffectiveCacheSize, &out.EffectiveCacheSize
		*out = new(string)
		**out = **in
	}
	if in.EffectiveIoConcurrency != nil {
		in, out := &in.EffectiveIoConcurrency, &out.EffectiveIoConcurrency
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]PgsqlLoggingObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MaintenanceWorkMem != nil {
		in, out := &in.MaintenanceWorkMem, &out.MaintenanceWorkMem
		*out = new(string)
		**out = **in
	}
	if in.MaxConnections != nil {
		in, out := &in.MaxConnections, &out.MaxConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxParallelMaintenanceWorkers != nil {
		in, out := &in.MaxParallelMaintenanceWorkers, &out.MaxParallelMaintenanceWorkers
		*out = new(float64)
		**out = **in
	}
	if in.MaxParallelWorkers != nil {
		in, out := &in.MaxParallelWorkers, &out.MaxParallelWorkers
		*out = new(float64)
		**out = **in
	}
	if in.MaxParallelWorkersPerGather != nil {
		in, out := &in.MaxParallelWorkersPerGather, &out.MaxParallelWorkersPerGather
		*out = new(float64)
		**out = **in
	}
	if in.MaxWalSize != nil {
		in, out := &in.MaxWalSize, &out.MaxWalSize
		*out = new(string)
		**out = **in
	}
	if in.MaxWorkerProcesses != nil {
		in, out := &in.MaxWorkerProcesses, &out.MaxWorkerProcesses
		*out = new(float64)
		**out = **in
	}
	if in.MinWalSize != nil {
		in, out := &in.MinWalSize, &out.MinWalSize
		*out = new(string)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]PgsqlMonitoringObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.ReplicationMode != nil {
		in, out := &in.ReplicationMode, &out.ReplicationMode
		*out = new(string)
		**out = **in
	}
	if in.SharedBuffers != nil {
		in, out := &in.SharedBuffers, &out.SharedBuffers
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]PgsqlUserObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
	if in.WalBuffers != nil {
		in, out := &in.WalBuffers, &out.WalBuffers
		*out = new(float64)
		**out = **in
	}
	if in.WalKeepSegments != nil {
		in, out := &in.WalKeepSegments, &out.WalKeepSegments
		*out = new(float64)
		**out = **in
	}
	if in.WorkMem != nil {
		in, out := &in.WorkMem, &out.WorkMem
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlObservation.
func (in *PgsqlObservation) DeepCopy() *PgsqlObservation {
	if in == nil {
		return nil
	}
	out := new(PgsqlObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlParameters) DeepCopyInto(out *PgsqlParameters) {
	*out = *in
	if in.Autovacuum != nil {
		in, out := &in.Autovacuum, &out.Autovacuum
		*out = new(string)
		**out = **in
	}
	if in.AutovacuumAnalyzeScaleFactor != nil {
		in, out := &in.AutovacuumAnalyzeScaleFactor, &out.AutovacuumAnalyzeScaleFactor
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumMaxWorkers != nil {
		in, out := &in.AutovacuumMaxWorkers, &out.AutovacuumMaxWorkers
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumVacuumCostDelay != nil {
		in, out := &in.AutovacuumVacuumCostDelay, &out.AutovacuumVacuumCostDelay
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumVacuumCostLimit != nil {
		in, out := &in.AutovacuumVacuumCostLimit, &out.AutovacuumVacuumCostLimit
		*out = new(float64)
		**out = **in
	}
	if in.AutovacuumVacuumScaleFactor != nil {
		in, out := &in.AutovacuumVacuumScaleFactor, &out.AutovacuumVacuumScaleFactor
		*out = new(float64)
		**out = **in
	}
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Database != nil {
		in, out := &in.Database, &out.Database
		*out = make([]PgsqlDatabaseParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EffectiveCacheSize != nil {
		in, out := &in.EffectiveCacheSize, &out.EffectiveCacheSize
		*out = new(string)
		**out = **in
	}
	if in.EffectiveIoConcurrency != nil {
		in, out := &in.EffectiveIoConcurrency, &out.EffectiveIoConcurrency
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]PgsqlLoggingParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MaintenanceWorkMem != nil {
		in, out := &in.MaintenanceWorkMem, &out.MaintenanceWorkMem
		*out = new(string)
		**out = **in
	}
	if in.MaxConnections != nil {
		in, out := &in.MaxConnections, &out.MaxConnections
		*out = new(float64)
		**out = **in
	}
	if in.MaxParallelMaintenanceWorkers != nil {
		in, out := &in.MaxParallelMaintenanceWorkers, &out.MaxParallelMaintenanceWorkers
		*out = new(float64)
		**out = **in
	}
	if in.MaxParallelWorkers != nil {
		in, out := &in.MaxParallelWorkers, &out.MaxParallelWorkers
		*out = new(float64)
		**out = **in
	}
	if in.MaxParallelWorkersPerGather != nil {
		in, out := &in.MaxParallelWorkersPerGather, &out.MaxParallelWorkersPerGather
		*out = new(float64)
		**out = **in
	}
	if in.MaxWalSize != nil {
		in, out := &in.MaxWalSize, &out.MaxWalSize
		*out = new(string)
		**out = **in
	}
	if in.MaxWorkerProcesses != nil {
		in, out := &in.MaxWorkerProcesses, &out.MaxWorkerProcesses
		*out = new(float64)
		**out = **in
	}
	if in.MinWalSize != nil {
		in, out := &in.MinWalSize, &out.MinWalSize
		*out = new(string)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]PgsqlMonitoringParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.ReplicationMode != nil {
		in, out := &in.ReplicationMode, &out.ReplicationMode
		*out = new(string)
		**out = **in
	}
	if in.SharedBuffers != nil {
		in, out := &in.SharedBuffers, &out.SharedBuffers
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = make([]PgsqlUserParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
	if in.WalBuffers != nil {
		in, out := &in.WalBuffers, &out.WalBuffers
		*out = new(float64)
		**out = **in
	}
	if in.WalKeepSegments != nil {
		in, out := &in.WalKeepSegments, &out.WalKeepSegments
		*out = new(float64)
		**out = **in
	}
	if in.WorkMem != nil {
		in, out := &in.WorkMem, &out.WorkMem
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlParameters.
func (in *PgsqlParameters) DeepCopy() *PgsqlParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlUserInitParameters) DeepCopyInto(out *PgsqlUserInitParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlUserInitParameters.
func (in *PgsqlUserInitParameters) DeepCopy() *PgsqlUserInitParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlUserInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlUserObservation) DeepCopyInto(out *PgsqlUserObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlUserObservation.
func (in *PgsqlUserObservation) DeepCopy() *PgsqlUserObservation {
	if in == nil {
		return nil
	}
	out := new(PgsqlUserObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PgsqlUserParameters) DeepCopyInto(out *PgsqlUserParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PgsqlUserParameters.
func (in *PgsqlUserParameters) DeepCopy() *PgsqlUserParameters {
	if in == nil {
		return nil
	}
	out := new(PgsqlUserParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RabbitmqInitParameters) DeepCopyInto(out *RabbitmqInitParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]RabbitmqLoggingInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]RabbitmqMonitoringInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RabbitmqInitParameters.
func (in *RabbitmqInitParameters) DeepCopy() *RabbitmqInitParameters {
	if in == nil {
		return nil
	}
	out := new(RabbitmqInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RabbitmqLoggingInitParameters) DeepCopyInto(out *RabbitmqLoggingInitParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RabbitmqLoggingInitParameters.
func (in *RabbitmqLoggingInitParameters) DeepCopy() *RabbitmqLoggingInitParameters {
	if in == nil {
		return nil
	}
	out := new(RabbitmqLoggingInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RabbitmqLoggingObservation) DeepCopyInto(out *RabbitmqLoggingObservation) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RabbitmqLoggingObservation.
func (in *RabbitmqLoggingObservation) DeepCopy() *RabbitmqLoggingObservation {
	if in == nil {
		return nil
	}
	out := new(RabbitmqLoggingObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RabbitmqLoggingParameters) DeepCopyInto(out *RabbitmqLoggingParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RabbitmqLoggingParameters.
func (in *RabbitmqLoggingParameters) DeepCopy() *RabbitmqLoggingParameters {
	if in == nil {
		return nil
	}
	out := new(RabbitmqLoggingParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RabbitmqMonitoringInitParameters) DeepCopyInto(out *RabbitmqMonitoringInitParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RabbitmqMonitoringInitParameters.
func (in *RabbitmqMonitoringInitParameters) DeepCopy() *RabbitmqMonitoringInitParameters {
	if in == nil {
		return nil
	}
	out := new(RabbitmqMonitoringInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RabbitmqMonitoringObservation) DeepCopyInto(out *RabbitmqMonitoringObservation) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RabbitmqMonitoringObservation.
func (in *RabbitmqMonitoringObservation) DeepCopy() *RabbitmqMonitoringObservation {
	if in == nil {
		return nil
	}
	out := new(RabbitmqMonitoringObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RabbitmqMonitoringParameters) DeepCopyInto(out *RabbitmqMonitoringParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RabbitmqMonitoringParameters.
func (in *RabbitmqMonitoringParameters) DeepCopy() *RabbitmqMonitoringParameters {
	if in == nil {
		return nil
	}
	out := new(RabbitmqMonitoringParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RabbitmqObservation) DeepCopyInto(out *RabbitmqObservation) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]RabbitmqLoggingObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]RabbitmqMonitoringObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RabbitmqObservation.
func (in *RabbitmqObservation) DeepCopy() *RabbitmqObservation {
	if in == nil {
		return nil
	}
	out := new(RabbitmqObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RabbitmqParameters) DeepCopyInto(out *RabbitmqParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]RabbitmqLoggingParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]RabbitmqMonitoringParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RabbitmqParameters.
func (in *RabbitmqParameters) DeepCopy() *RabbitmqParameters {
	if in == nil {
		return nil
	}
	out := new(RabbitmqParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisInitParameters) DeepCopyInto(out *RedisInitParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.ClusterType != nil {
		in, out := &in.ClusterType, &out.ClusterType
		*out = new(string)
		**out = **in
	}
	if in.Databases != nil {
		in, out := &in.Databases, &out.Databases
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]RedisLoggingInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MaxmemoryPolicy != nil {
		in, out := &in.MaxmemoryPolicy, &out.MaxmemoryPolicy
		*out = new(string)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]RedisMonitoringInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PersistenceAof != nil {
		in, out := &in.PersistenceAof, &out.PersistenceAof
		*out = new(bool)
		**out = **in
	}
	if in.PersistenceRdb != nil {
		in, out := &in.PersistenceRdb, &out.PersistenceRdb
		*out = new(bool)
		**out = **in
	}
	if in.TCPBacklog != nil {
		in, out := &in.TCPBacklog, &out.TCPBacklog
		*out = new(float64)
		**out = **in
	}
	if in.TCPKeepalive != nil {
		in, out := &in.TCPKeepalive, &out.TCPKeepalive
		*out = new(float64)
		**out = **in
	}
	if in.Timeout != nil {
		in, out := &in.Timeout, &out.Timeout
		*out = new(float64)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisInitParameters.
func (in *RedisInitParameters) DeepCopy() *RedisInitParameters {
	if in == nil {
		return nil
	}
	out := new(RedisInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisLoggingInitParameters) DeepCopyInto(out *RedisLoggingInitParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisLoggingInitParameters.
func (in *RedisLoggingInitParameters) DeepCopy() *RedisLoggingInitParameters {
	if in == nil {
		return nil
	}
	out := new(RedisLoggingInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisLoggingObservation) DeepCopyInto(out *RedisLoggingObservation) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisLoggingObservation.
func (in *RedisLoggingObservation) DeepCopy() *RedisLoggingObservation {
	if in == nil {
		return nil
	}
	out := new(RedisLoggingObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisLoggingParameters) DeepCopyInto(out *RedisLoggingParameters) {
	*out = *in
	if in.LogTo != nil {
		in, out := &in.LogTo, &out.LogTo
		*out = new(string)
		**out = **in
	}
	if in.LoggingTags != nil {
		in, out := &in.LoggingTags, &out.LoggingTags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisLoggingParameters.
func (in *RedisLoggingParameters) DeepCopy() *RedisLoggingParameters {
	if in == nil {
		return nil
	}
	out := new(RedisLoggingParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisMonitoringInitParameters) DeepCopyInto(out *RedisMonitoringInitParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisMonitoringInitParameters.
func (in *RedisMonitoringInitParameters) DeepCopy() *RedisMonitoringInitParameters {
	if in == nil {
		return nil
	}
	out := new(RedisMonitoringInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisMonitoringObservation) DeepCopyInto(out *RedisMonitoringObservation) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisMonitoringObservation.
func (in *RedisMonitoringObservation) DeepCopy() *RedisMonitoringObservation {
	if in == nil {
		return nil
	}
	out := new(RedisMonitoringObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisMonitoringParameters) DeepCopyInto(out *RedisMonitoringParameters) {
	*out = *in
	if in.MonitorBy != nil {
		in, out := &in.MonitorBy, &out.MonitorBy
		*out = new(string)
		**out = **in
	}
	if in.MonitoringLabels != nil {
		in, out := &in.MonitoringLabels, &out.MonitoringLabels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisMonitoringParameters.
func (in *RedisMonitoringParameters) DeepCopy() *RedisMonitoringParameters {
	if in == nil {
		return nil
	}
	out := new(RedisMonitoringParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisObservation) DeepCopyInto(out *RedisObservation) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.ClusterType != nil {
		in, out := &in.ClusterType, &out.ClusterType
		*out = new(string)
		**out = **in
	}
	if in.Databases != nil {
		in, out := &in.Databases, &out.Databases
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]RedisLoggingObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MaxmemoryPolicy != nil {
		in, out := &in.MaxmemoryPolicy, &out.MaxmemoryPolicy
		*out = new(string)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]RedisMonitoringObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.PersistenceAof != nil {
		in, out := &in.PersistenceAof, &out.PersistenceAof
		*out = new(bool)
		**out = **in
	}
	if in.PersistenceRdb != nil {
		in, out := &in.PersistenceRdb, &out.PersistenceRdb
		*out = new(bool)
		**out = **in
	}
	if in.TCPBacklog != nil {
		in, out := &in.TCPBacklog, &out.TCPBacklog
		*out = new(float64)
		**out = **in
	}
	if in.TCPKeepalive != nil {
		in, out := &in.TCPKeepalive, &out.TCPKeepalive
		*out = new(float64)
		**out = **in
	}
	if in.Timeout != nil {
		in, out := &in.Timeout, &out.Timeout
		*out = new(float64)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisObservation.
func (in *RedisObservation) DeepCopy() *RedisObservation {
	if in == nil {
		return nil
	}
	out := new(RedisObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RedisParameters) DeepCopyInto(out *RedisParameters) {
	*out = *in
	if in.Class != nil {
		in, out := &in.Class, &out.Class
		*out = new(string)
		**out = **in
	}
	if in.ClusterType != nil {
		in, out := &in.ClusterType, &out.ClusterType
		*out = new(string)
		**out = **in
	}
	if in.Databases != nil {
		in, out := &in.Databases, &out.Databases
		*out = new(float64)
		**out = **in
	}
	if in.Logging != nil {
		in, out := &in.Logging, &out.Logging
		*out = make([]RedisLoggingParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MaxmemoryPolicy != nil {
		in, out := &in.MaxmemoryPolicy, &out.MaxmemoryPolicy
		*out = new(string)
		**out = **in
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make([]RedisMonitoringParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Options != nil {
		in, out := &in.Options, &out.Options
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PersistenceAof != nil {
		in, out := &in.PersistenceAof, &out.PersistenceAof
		*out = new(bool)
		**out = **in
	}
	if in.PersistenceRdb != nil {
		in, out := &in.PersistenceRdb, &out.PersistenceRdb
		*out = new(bool)
		**out = **in
	}
	if in.TCPBacklog != nil {
		in, out := &in.TCPBacklog, &out.TCPBacklog
		*out = new(float64)
		**out = **in
	}
	if in.TCPKeepalive != nil {
		in, out := &in.TCPKeepalive, &out.TCPKeepalive
		*out = new(float64)
		**out = **in
	}
	if in.Timeout != nil {
		in, out := &in.Timeout, &out.Timeout
		*out = new(float64)
		**out = **in
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RedisParameters.
func (in *RedisParameters) DeepCopy() *RedisParameters {
	if in == nil {
		return nil
	}
	out := new(RedisParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RootVolumeInitParameters) DeepCopyInto(out *RootVolumeInitParameters) {
	*out = *in
	if in.Iops != nil {
		in, out := &in.Iops, &out.Iops
		*out = new(float64)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RootVolumeInitParameters.
func (in *RootVolumeInitParameters) DeepCopy() *RootVolumeInitParameters {
	if in == nil {
		return nil
	}
	out := new(RootVolumeInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RootVolumeObservation) DeepCopyInto(out *RootVolumeObservation) {
	*out = *in
	if in.Iops != nil {
		in, out := &in.Iops, &out.Iops
		*out = new(float64)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RootVolumeObservation.
func (in *RootVolumeObservation) DeepCopy() *RootVolumeObservation {
	if in == nil {
		return nil
	}
	out := new(RootVolumeObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RootVolumeParameters) DeepCopyInto(out *RootVolumeParameters) {
	*out = *in
	if in.Iops != nil {
		in, out := &in.Iops, &out.Iops
		*out = new(float64)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RootVolumeParameters.
func (in *RootVolumeParameters) DeepCopy() *RootVolumeParameters {
	if in == nil {
		return nil
	}
	out := new(RootVolumeParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Service) DeepCopyInto(out *Service) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Service.
func (in *Service) DeepCopy() *Service {
	if in == nil {
		return nil
	}
	out := new(Service)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Service) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceInitParameters) DeepCopyInto(out *ServiceInitParameters) {
	*out = *in
	if in.ArbitratorRequired != nil {
		in, out := &in.ArbitratorRequired, &out.ArbitratorRequired
		*out = new(bool)
		**out = **in
	}
	if in.BackupSettings != nil {
		in, out := &in.BackupSettings, &out.BackupSettings
		*out = make([]BackupSettingsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DataVolume != nil {
		in, out := &in.DataVolume, &out.DataVolume
		*out = make([]DataVolumeInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DeleteInterfacesOnDestroy != nil {
		in, out := &in.DeleteInterfacesOnDestroy, &out.DeleteInterfacesOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.Elasticsearch != nil {
		in, out := &in.Elasticsearch, &out.Elasticsearch
		*out = make([]ElasticsearchInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.HighAvailability != nil {
		in, out := &in.HighAvailability, &out.HighAvailability
		*out = new(bool)
		**out = **in
	}
	if in.InstanceType != nil {
		in, out := &in.InstanceType, &out.InstanceType
		*out = new(string)
		**out = **in
	}
	if in.Memcached != nil {
		in, out := &in.Memcached, &out.Memcached
		*out = make([]MemcachedInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodb != nil {
		in, out := &in.Mongodb, &out.Mongodb
		*out = make([]MongodbInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQL != nil {
		in, out := &in.MySQL, &out.MySQL
		*out = make([]MySQLInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.NetworkInterfaceIds != nil {
		in, out := &in.NetworkInterfaceIds, &out.NetworkInterfaceIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Pgsql != nil {
		in, out := &in.Pgsql, &out.Pgsql
		*out = make([]PgsqlInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Rabbitmq != nil {
		in, out := &in.Rabbitmq, &out.Rabbitmq
		*out = make([]RabbitmqInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = make([]RedisInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RootVolume != nil {
		in, out := &in.RootVolume, &out.RootVolume
		*out = make([]RootVolumeInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SSHKeyName != nil {
		in, out := &in.SSHKeyName, &out.SSHKeyName
		*out = new(string)
		**out = **in
	}
	if in.SecurityGroupIds != nil {
		in, out := &in.SecurityGroupIds, &out.SecurityGroupIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SubnetIds != nil {
		in, out := &in.SubnetIds, &out.SubnetIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UserData != nil {
		in, out := &in.UserData, &out.UserData
		*out = new(string)
		**out = **in
	}
	if in.UserDataContentType != nil {
		in, out := &in.UserDataContentType, &out.UserDataContentType
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceInitParameters.
func (in *ServiceInitParameters) DeepCopy() *ServiceInitParameters {
	if in == nil {
		return nil
	}
	out := new(ServiceInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceList) DeepCopyInto(out *ServiceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Service, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceList.
func (in *ServiceList) DeepCopy() *ServiceList {
	if in == nil {
		return nil
	}
	out := new(ServiceList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServiceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceObservation) DeepCopyInto(out *ServiceObservation) {
	*out = *in
	if in.ArbitratorRequired != nil {
		in, out := &in.ArbitratorRequired, &out.ArbitratorRequired
		*out = new(bool)
		**out = **in
	}
	if in.AutoCreatedSecurityGroupIds != nil {
		in, out := &in.AutoCreatedSecurityGroupIds, &out.AutoCreatedSecurityGroupIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AvailableEnvironmentVersions != nil {
		in, out := &in.AvailableEnvironmentVersions, &out.AvailableEnvironmentVersions
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.BackupSettings != nil {
		in, out := &in.BackupSettings, &out.BackupSettings
		*out = make([]BackupSettingsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DataVolume != nil {
		in, out := &in.DataVolume, &out.DataVolume
		*out = make([]DataVolumeObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DeleteInterfacesOnDestroy != nil {
		in, out := &in.DeleteInterfacesOnDestroy, &out.DeleteInterfacesOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.Elasticsearch != nil {
		in, out := &in.Elasticsearch, &out.Elasticsearch
		*out = make([]ElasticsearchObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Endpoints != nil {
		in, out := &in.Endpoints, &out.Endpoints
		*out = make([]EndpointsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EnvironmentVersion != nil {
		in, out := &in.EnvironmentVersion, &out.EnvironmentVersion
		*out = new(string)
		**out = **in
	}
	if in.ErrorCode != nil {
		in, out := &in.ErrorCode, &out.ErrorCode
		*out = new(string)
		**out = **in
	}
	if in.ErrorDescription != nil {
		in, out := &in.ErrorDescription, &out.ErrorDescription
		*out = new(string)
		**out = **in
	}
	if in.HighAvailability != nil {
		in, out := &in.HighAvailability, &out.HighAvailability
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceType != nil {
		in, out := &in.InstanceType, &out.InstanceType
		*out = new(string)
		**out = **in
	}
	if in.Instances != nil {
		in, out := &in.Instances, &out.Instances
		*out = make([]InstancesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Memcached != nil {
		in, out := &in.Memcached, &out.Memcached
		*out = make([]MemcachedObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodb != nil {
		in, out := &in.Mongodb, &out.Mongodb
		*out = make([]MongodbObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQL != nil {
		in, out := &in.MySQL, &out.MySQL
		*out = make([]MySQLObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.NetworkInterfaceIds != nil {
		in, out := &in.NetworkInterfaceIds, &out.NetworkInterfaceIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Pgsql != nil {
		in, out := &in.Pgsql, &out.Pgsql
		*out = make([]PgsqlObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Rabbitmq != nil {
		in, out := &in.Rabbitmq, &out.Rabbitmq
		*out = make([]RabbitmqObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = make([]RedisObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RootVolume != nil {
		in, out := &in.RootVolume, &out.RootVolume
		*out = make([]RootVolumeObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SSHKeyName != nil {
		in, out := &in.SSHKeyName, &out.SSHKeyName
		*out = new(string)
		**out = **in
	}
	if in.SecurityGroupIds != nil {
		in, out := &in.SecurityGroupIds, &out.SecurityGroupIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ServiceClass != nil {
		in, out := &in.ServiceClass, &out.ServiceClass
		*out = new(string)
		**out = **in
	}
	if in.ServiceType != nil {
		in, out := &in.ServiceType, &out.ServiceType
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.SubnetIds != nil {
		in, out := &in.SubnetIds, &out.SubnetIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SupportedFeatures != nil {
		in, out := &in.SupportedFeatures, &out.SupportedFeatures
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TotalCPUCount != nil {
		in, out := &in.TotalCPUCount, &out.TotalCPUCount
		*out = new(float64)
		**out = **in
	}
	if in.TotalMemory != nil {
		in, out := &in.TotalMemory, &out.TotalMemory
		*out = new(float64)
		**out = **in
	}
	if in.UserData != nil {
		in, out := &in.UserData, &out.UserData
		*out = new(string)
		**out = **in
	}
	if in.UserDataContentType != nil {
		in, out := &in.UserDataContentType, &out.UserDataContentType
		*out = new(string)
		**out = **in
	}
	if in.VPCID != nil {
		in, out := &in.VPCID, &out.VPCID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceObservation.
func (in *ServiceObservation) DeepCopy() *ServiceObservation {
	if in == nil {
		return nil
	}
	out := new(ServiceObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceParameters) DeepCopyInto(out *ServiceParameters) {
	*out = *in
	if in.ArbitratorRequired != nil {
		in, out := &in.ArbitratorRequired, &out.ArbitratorRequired
		*out = new(bool)
		**out = **in
	}
	if in.BackupSettings != nil {
		in, out := &in.BackupSettings, &out.BackupSettings
		*out = make([]BackupSettingsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DataVolume != nil {
		in, out := &in.DataVolume, &out.DataVolume
		*out = make([]DataVolumeParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DeleteInterfacesOnDestroy != nil {
		in, out := &in.DeleteInterfacesOnDestroy, &out.DeleteInterfacesOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.Elasticsearch != nil {
		in, out := &in.Elasticsearch, &out.Elasticsearch
		*out = make([]ElasticsearchParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.HighAvailability != nil {
		in, out := &in.HighAvailability, &out.HighAvailability
		*out = new(bool)
		**out = **in
	}
	if in.InstanceType != nil {
		in, out := &in.InstanceType, &out.InstanceType
		*out = new(string)
		**out = **in
	}
	if in.Memcached != nil {
		in, out := &in.Memcached, &out.Memcached
		*out = make([]MemcachedParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Mongodb != nil {
		in, out := &in.Mongodb, &out.Mongodb
		*out = make([]MongodbParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MySQL != nil {
		in, out := &in.MySQL, &out.MySQL
		*out = make([]MySQLParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.NetworkInterfaceIds != nil {
		in, out := &in.NetworkInterfaceIds, &out.NetworkInterfaceIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Pgsql != nil {
		in, out := &in.Pgsql, &out.Pgsql
		*out = make([]PgsqlParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Rabbitmq != nil {
		in, out := &in.Rabbitmq, &out.Rabbitmq
		*out = make([]RabbitmqParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Redis != nil {
		in, out := &in.Redis, &out.Redis
		*out = make([]RedisParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RootVolume != nil {
		in, out := &in.RootVolume, &out.RootVolume
		*out = make([]RootVolumeParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SSHKeyName != nil {
		in, out := &in.SSHKeyName, &out.SSHKeyName
		*out = new(string)
		**out = **in
	}
	if in.SecurityGroupIds != nil {
		in, out := &in.SecurityGroupIds, &out.SecurityGroupIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.SubnetIds != nil {
		in, out := &in.SubnetIds, &out.SubnetIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UserData != nil {
		in, out := &in.UserData, &out.UserData
		*out = new(string)
		**out = **in
	}
	if in.UserDataContentType != nil {
		in, out := &in.UserDataContentType, &out.UserDataContentType
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceParameters.
func (in *ServiceParameters) DeepCopy() *ServiceParameters {
	if in == nil {
		return nil
	}
	out := new(ServiceParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceSpec) DeepCopyInto(out *ServiceSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSpec.
func (in *ServiceSpec) DeepCopy() *ServiceSpec {
	if in == nil {
		return nil
	}
	out := new(ServiceSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServiceStatus) DeepCopyInto(out *ServiceStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceStatus.
func (in *ServiceStatus) DeepCopy() *ServiceStatus {
	if in == nil {
		return nil
	}
	out := new(ServiceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserInitParameters) DeepCopyInto(out *UserInitParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Roles != nil {
		in, out := &in.Roles, &out.Roles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserInitParameters.
func (in *UserInitParameters) DeepCopy() *UserInitParameters {
	if in == nil {
		return nil
	}
	out := new(UserInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserObservation) DeepCopyInto(out *UserObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Roles != nil {
		in, out := &in.Roles, &out.Roles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserObservation.
func (in *UserObservation) DeepCopy() *UserObservation {
	if in == nil {
		return nil
	}
	out := new(UserObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserParameters) DeepCopyInto(out *UserParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Roles != nil {
		in, out := &in.Roles, &out.Roles
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserParameters.
func (in *UserParameters) DeepCopy() *UserParameters {
	if in == nil {
		return nil
	}
	out := new(UserParameters)
	in.DeepCopyInto(out)
	return out
}
